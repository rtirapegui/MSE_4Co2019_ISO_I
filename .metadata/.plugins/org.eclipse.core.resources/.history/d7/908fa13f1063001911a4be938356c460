/*
===============================================================================
 Name        : main.c
 Author      : $(Rodrigo Tirapegui)
 Version     :
 Copyright   : $(copyright)
 Description :
===============================================================================
*/
#include <stdarg.h>
#include <stdio.h>
#include "chip.h"
#include "board.h"
#include "os.h"

/****************
 *	Constants	*
 * *************/
#define STACK_SIZE_BYTES   512

/**********
 *	Types *
 *********/
typedef struct
{
   uint8_t  tecIndex;
   tick_t	eventTickstamp;
   bool     eventByFallingEdge;
} ISRQueue_data_t;

typedef struct
{
	tick_t	pulseTickCount;
} tasksQueue_data_t;

typedef struct
{
   uint8_t  bIndexX;
   uint8_t  bIndexY;
   uint32_t intervalMs;
} LOGQueue_data_t;

/**********************
 *	Application Tasks *
 *********************/

/*
 * Example to test tasks priority scheduling
 */

OS_TASK_CREATE(Tarea_1, STACK_SIZE_BYTES, A_Task, (void *) 0x11223344, TASK_PRIORITY_IDLE + 3);
OS_TASK_CREATE(Tarea_2, STACK_SIZE_BYTES, B_Task, (void *) 0x11223344, TASK_PRIORITY_IDLE + 1);
OS_TASK_CREATE(Tarea_3, STACK_SIZE_BYTES, log_Task, (void *) 0x11223344, TASK_PRIORITY_IDLE + 2);

OS_QUEUE_CREATE(ISR_Queue, 2, sizeof(ISRQueue_data_t));
OS_QUEUE_CREATE(Task_Queue, 1, sizeof(tasksQueue_data_t));
OS_QUEUE_CREATE(Log_Queue, 10, sizeof(LOGQueue_data_t));

/************************
 *	Private functions	*
 ***********************/
static void initHardware(void)
{
	// Set up and initialize all required blocks and
    // functions related to the board hardware
	Board_Init();
}
static void tec_1_handler(btnIRQEdge_t edge)
{
	ISRQueue_data_t ISRDataElement;

	ISRDataElement.eventTickstamp = os_task_getTickCount();
	ISRDataElement.tecIndex = 0;

	if(FALLING_EDGE == edge)
	{
		ISRDataElement.eventByFallingEdge = true;
	}
	else
	{
		ISRDataElement.eventByFallingEdge = false;
	}

	// Insert element into TasksQueue
	os_queue_send(ISR_Queue, &ISRDataElement, 0);
}
static uint32_t formatVariadicString(uint8_t *buf, uint32_t bufSize, const uint8_t* format, ...)
{
   int32_t size;
   va_list arg;

   va_start(arg, format);
   size = vsnprintf((char *) buf, bufSize, (const char *) format, arg);
   va_end(arg);

   if(size < 0)
      size = 0;

   return (uint32_t) size;
}
void * A_Task(void *arg)
{
   #define DEBOUNCE  40 // In ms

   ISRQueue_data_t ISRDataElement;
   tasksQueue_data_t tasksDataElement;
   tick_t t0Tickstamp, t1Tickstamp, diffTicks;

   while(true)
   {
	 if(true == os_queue_receive(ISR_Queue, &ISRDataElement, OS_TICK_MAX))
	 {
		if(0 == ISRDataElement.tecIndex)
		{
		   if(ISRDataElement.eventByFallingEdge)
		   {
			  t0Tickstamp = ISRDataElement.eventTickstamp;
		   }
		   else
		   {
			  t1Tickstamp = ISRDataElement.eventTickstamp;

			  diffTicks = (t1Tickstamp > t0Tickstamp ? t1Tickstamp - t0Tickstamp : 0xFFFFFFFF - t0Tickstamp + t1Tickstamp);

			  if(DEBOUNCE / OS_TICK_PERIOD_MS < diffTicks)
			  {
				  tasksDataElement.pulseTickCount = diffTicks;

				  // Insert element into TasksQueue
				  os_queue_send(Task_Queue, &tasksDataElement, 0);

				  // Insert element into LogQueue
				  LOGQueue_data_t logElement;

				  logElement.bIndexX    = true;
				  logElement.bIndexY    = false;
				  logElement.intervalMs = diffTicks;

				  os_queue_send(Log_Queue, &logElement, 0);
			  }
		   }
		}
	 }
   }

   return NULL;
}
void * B_Task(void *arg)
{
   #define LED_ON_DIVIDER  2
   tasksQueue_data_t tasksDataElement;
   tick_t ledPeriodTicks = 0;
   tick_t startPeriodTick;

   while(true)
   {
      if(true == os_queue_receive(Task_Queue, &tasksDataElement, 0))
	  {
	     ledPeriodTicks = 2*tasksDataElement.pulseTickCount;
	     startPeriodTick = os_task_getTickCount();
	  }
	  else
	  {
		if(0 != ledPeriodTicks)
		{
		   Board_LED_Set(LED_BLUE, true);
		   os_task_delay(ledPeriodTicks/2);
		   Board_LED_Set(LED_BLUE, false);

		   os_task_delayUntil(&startPeriodTick, ledPeriodTicks);
		}
	  }
   }

   return NULL;
}
void * log_Task(void * arg)
{
   #define MSG_SIZE         30

   LOGQueue_data_t logData;

   while(true)
   {
	 if(true == os_queue_receive(Log_Queue, &logData, 0))
	 {
		uint8_t msg[MSG_SIZE] = { 0 };

		formatVariadicString(msg, sizeof(msg), (const uint8_t*) "{%d:%d:%d}\r\n", logData.bIndexX, logData.bIndexY, logData.intervalMs);

		Board_UART_WriteString(msg);
	 }
   }

   return NULL;
}

/************************
 *	Public functions	*
 ***********************/
int main(void)
{
	/* Initialize board hardware */
	initHardware();

	/* Register button IRQ handler */
	Board_BUTTON_registerIRQHandler(TEC_1, tec_1_handler);

	/* Stay forever */
	os_start();
}

